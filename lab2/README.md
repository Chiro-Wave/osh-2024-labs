**`cd`**

chdir()接受一个字符型指针作为路径跳转的参数，不能留空。相对路径和绝对路径都被接受。
**选做** `cd` 在没有第二个参数时，默认进入家目录。通过`std::getenv("HOME")`来获取环境变量"HOME"对应的路径，作为参数传入chdir()即可。

**`重定向`**

> 考虑重定向和管道的组合使用在Ubuntu中的实际效果
>
> 正确的写法：命令1 < 输入文件 | 命令2 ...
> 命令1的输入重定向到输入文件，输出重定向到管道
>
> 错误的写法：命令1 | 命令2  ... < 输入文件
> 命令2的输入先重定向到管道，再重定向到输入文件，实际上命令1向管道写入的数据没有被使用
>
> 本实验认为在一行命令中至多使用重定向加入一个输入文件，且输入文件输入到第一个命令的进程。

>考虑错误写法在Ubuntu中实际导致的结果
>
>命令1 > 输出文件1 > 输出文件2
>'>' 对应打开文件并清空其原有内容，文件1和2都会被清空。上述错误写法先将命令1的输出重定向>到文件1，再重定向到文件2，最终只有文件2写入了命令的输出，而文件1只被清空。
>
>命令1 >>输出文件1 >>输出文件2
>'>>'对应打开文件并将写入位置移动到文件末尾，文件1和2都不会被清空。上述错误写法先将命令>1的输出重定向到文件1，再重定向到文件2，最终只有文件2写入了命令的输出，而文件1不动。
>
>这种错误写法可能导致文件1被打开但是没有关闭，本实验中考虑了这一点，通过检测是否已有打开的接收输出的文件、如有则关闭来防止文件未关闭的隐患。
>
>```c++
>      if (args[i].compare(">>") == 0)
>      {
>        if (i + 1 == args.size())
>        {
>          perror("Missing target file after \">>\"");
>          return 0;
>        }
>        if (file_w != -1) // 错误检查：有多个>或>>存在，仅最后一个有效，此前打开的文件要关闭
>          close(file_w);
>        file_w = open(args[++i].c_str(), O_WRONLY | O_APPEND);
>        continue;
>      }
>```

> **疑难杂症**
>
> windows下复制获得的Makefile在移动到linux系统后报错缺少分割符。使用cat -e -t -v Makefile可以查看Makefile，并显示特殊字符的转义形式。windows下使用CRLF换行，linux下使用LF换行，vscode界面右下角可以快速转换。vscode中使用Tab可设置使用制表符/空格，Makefile要求使用制表符，默认的空格缩进会导致报错缺少分割符。

